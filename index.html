<!--

Copyright 2024 Chris MacMackin

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

-->

<!DOCTYPE html>
    <html lang="en">
    <head>
	    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
        <!-- Load plotly.js into the DOM -->
        <script src='https://cdn.plot.ly/plotly-2.34.0.min.js'></script>
        <!-- Load Grist extension API into DOM -->
        <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

		<style>
            /* Style the tab */
            .tab {
              overflow: hidden;
              background-color: #F7F7F7;
            }
            
            /* Style the buttons that are used to open the tab content */
            .tab button {
              background-color: inherit;
              float: left;
              border: none;
              outline: none;
              cursor: pointer;
              padding: 14px 16px;
              transition: 0.3s;
            }
            
            /* Change background color of buttons on hover */
            .tab button:hover {
              background-color: #eeeeee;
            }
            
            /* Create an active/current tablink class */
            .tab button.active {
              background-color: #E5E5E5;
            }
            
            /* Style the tab content */
            .tabcontent {
              display: none;
              padding: 6px 12px;
			  animation: fadeEffect 1s; /* Fading effect takes 1 second */
            }

			/* Go from zero to full opacity */
			@keyframes fadeEffect {
				from {opacity: 0;}
				to {opacity: 1;}
			}

			* {
				font-family: Liberation Sans, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;
			}

			body {
				margin: 0;
			}
		</style>
    </head>
    
    <body>
	  <div id="navbar" class="tab charts"></div>

	  <div id="tab_content">Waiting for data...</div>
	  <script>
		function percentage(num, denom) {
			return num.map((n, i) => n / denom[i] * 100);
		}

		function changeTab(evt, name) {
            // Declare all variables
            var i, tabcontent, tablinks;
          
            // Get all elements with class="tabcontent" and hide them
            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
              tabcontent[i].style.display = "none";
            }
          
            // Get all elements with class="tablinks" and remove the class "active"
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
              tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
          
            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(name).style.display = "block";
            evt.currentTarget.className += " active";
        }


		// Whether a column is internal and should be hidden.
		function isHiddenCol(colId) {
			return colId.startsWith('gristHelper_') || colId === 'manualSort';
		}

		async function getColumns() {
            const tableId = await grist.selectedTable.getTableId();
            const tables = await grist.docApi.fetchTable('_grist_Tables');
            const columns = await grist.docApi.fetchTable('_grist_Tables_column');
            const tableRef = tables.id[tables.tableId.indexOf(tableId)];
            const columnRecords = columns.id.map((_id, i) =>
              Object.fromEntries(Object.keys(columns).map(key => [key, columns[key][i]]))
            );
            return columnRecords.filter(
				col => col.parentId === tableRef
					&& !isHiddenCol(col.colId)
					&& col.type !== "Attachments"
            );
        }
          

		grist.ready({
			requiredAccess: 'full', // Need this in order to get column display names
			allowSelectBy: true,
			columns: [
				{
					name: "Hierarchy",
					title: "Hierarchical data",
					description: "The 'path' to each sector of the plot",
					type: "ChoiceList,RefList"
				},
				{
					name: "Size",
					title: "Sector size",
					//description: "Number of people represented by each sector of the plot",
					type: "Int"
				},
				{
					name: "Coverage",
					title: "Sector coverage",
					description: "Number of people considered 'covered' in each sector of the plot",
					type: "Int",
					allowMultiple: true
				},
			]
		});

		// TODO: Display the path/trace (incorporate into click event
		// for selecting divisions?) 
		// TODO: Set the selected division in grist
		// TODO: Allow a label other than "employees" to be used in
		// the hovertext
		function findColumnLabel(columns, id) {
			for (let i = 0; i < columns.length; i++) {
				if (columns[i].colId == id) {
					return columns[i].label;
				}
			}
			return id;
		}
		
		grist.onRecords(async function(records, mapping) {
			const mapped = grist.mapColumnNames(records);
    
    		// Create a sunburst plot in the given holder element.
    		function make_sunburst(holder, labels, ids, parents, sizes,
    							   coverages, name) {
       			var data = [{
       				type: "icicle",
       				labels: labels,
       				ids: ids,
       				parents: parents,
       				values:  sizes,
       				customdata: coverages,
       				hovertemplate: "<b>%{label}</b> <br> Employees: %{value} <br> " +
    					name + ": %{customdata}, %{color:.2f}%<extra></extra>",
       				branchvalues: "total",
       				marker: {
       					"colors": percentage(coverages, sizes),
       					"colorscale": [
    						["0.0", "rgb(165,0,38)"],
    						["0.1", "rgb(215,48,39)"],
    						["0.2", "rgb(244,109,67)"],
    						["0.3", "rgb(253,174,97)"],
    						["0.4", "rgb(254,224,139)"],
    						["0.5", "rgb(255,255,191)"],
    						["0.6", "rgb(217,239,139)"],
    						["0.7", "rgb(166,217,106)"],
    						["0.8", "rgb(102,189,99)"],
    						["0.9", "rgb(26,152,80)"],
    						["1.0", "rgb(0,104,55)"],
    					],
    					"showscale": true,
        			},
    				maxdepth: 4,
					tiling: {
						orientation: 'v';
					},
					pathbar: {
						textfont: {size: 1.3}
					}
        		}];
        		var layout = {
        			margin: {l: 10, r: 10, b: 10, t: 45},
    				cmin: 0,
    				cmax: 100,
					height: 430,
        		};
    			var config = {responsive: true};
    			Plotly.newPlot(holder, data, layout, config);
    			holder.on('plotly_icicleclick', function (evt){
					console.log(evt.nextLevel);
					console.log(evt.points[0]);					
					if (evt.nextLevel == null || evt.nextLevel == evt.points[0].id) {
						console.log("Setting cursor to CLICKED item");
    					grist.setCursorPos({rowId: records.id[evt.points[0].pointNumber]});
					} else {
						console.log("Setting cursor to PARENT item");
						grist.setCursorPos({rowId: records.id[evt.points[0].data.ids.indexOf(evt.nextLevel)]});
					}
					// FIXME: How do I indicate focus has shifted to a
    				// leaf? How do I shift focus away from it again?
						
    			});
    		}
    
    
			if (mapped) {
				const _columns = getColumns();
        		const labels = mapped.Hierarchy.map((h) => h[h.length - 1].replace(
    				/(?![^\n]{1,25}$)([^\n]{1,25})\s/g, '$1<br>'
    			));
        		const ids =  mapped.Hierarchy.map((h) => h.toString());
        		const parents = mapped.Hierarchy.map((h) => h.slice(0, -1).toString());
        		const sizes = mapped.Size;

    			const contents = document.getElementById("tab_content");
    			const navbar = document.getElementById("navbar");
    			contents.textContent = '';
				const columns = await _columns;
				if (mapping.Coverage.length > 1) {
    				navbar.textContent = '';
    				mapping.Coverage.forEach(function (data, i) {
    					const name = findColumnLabel(columns, data);
    					const holder = document.createElement("div");
						holder.id = data;
						holder.classList.add("tabcontent");
    					contents.appendChild(holder);
    					make_sunburst(holder, labels, ids, parents, sizes,
    								  mapped.Coverage[i], name);
						const button =
    						  document.createElement("button");
						const button_label =
    						  document.createTextNode(name);
						button.id = data + "_button";
						button.appendChild(button_label);
						button.classList.add("tablinks");
						button.addEventListener('click', function (e) {changeTab(e, data);});
						navbar.appendChild(button);
    				});
					document.getElementById(mapping.Coverage[0] + "_button").click();
				} else {
					data = mapping.Coverage[0];
    				const name = findColumnLabel(columns, data);
    				const holder = document.createElement("div");
    				contents.appendChild(holder);
    				make_sunburst(holder, labels, ids, parents, sizes,
    							  mapped.Coverage[0], name);
					navbar.style.display = 'none';
				}
    		} else {
				document.getElementById('tab_content').innerText = "Please map all columns";
				console.error("Please map all columns");
			}			
		}, {format: "columns"});
	  </script>
    </body>
</html>
